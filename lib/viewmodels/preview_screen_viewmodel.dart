import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'dart:io';
import '../../models/cliente.dart';
import 'package:ada_app/repositories/equipo_cliente_repository.dart';
import 'package:ada_app/repositories/estado_equipo_repository.dart';
import 'package:ada_app/models/estado_equipo.dart';
import 'dart:async';

final _logger = Logger();

class PreviewScreenViewModel extends ChangeNotifier {
  bool _isLoading = false;
  String? _statusMessage;

  // Repositorios para el guardado definitivo
  final EquipoClienteRepository _equipoClienteRepository = EquipoClienteRepository();
  final EstadoEquipoRepository _estadoEquipoRepository = EstadoEquipoRepository();

  // ‚ö†Ô∏è CAMBIAR ESTA IP POR LA IP DE TU SERVIDOR
  static const String _baseUrl = 'https://56a494bb0732.ngrok-free.app/adaControl/api/';
  static const String _estadosEndpoint = '/insertCensoActivo';
  static const String _pingEndpoint = '/ping';

  bool get isLoading => _isLoading;
  String? get statusMessage => _statusMessage;

  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setStatusMessage(String? message) {
    _statusMessage = message;
    notifyListeners();
  }

  String formatearFecha(String? fechaIso) {
    if (fechaIso == null) return 'No disponible';

    try {
      final fecha = DateTime.parse(fechaIso);
      final dia = fecha.day.toString().padLeft(2, '0');
      final mes = fecha.month.toString().padLeft(2, '0');
      final ano = fecha.year;
      final hora = fecha.hour.toString().padLeft(2, '0');
      final minuto = fecha.minute.toString().padLeft(2, '0');

      return '$dia/$mes/$ano - $hora:$minuto';
    } catch (e) {
      return 'Formato inv√°lido';
    }
  }

  // ============================================================================
  // AQU√ç ES DONDE OCURRE EL GUARDADO DEFINITIVO
  // ============================================================================
  Future<Map<String, dynamic>> confirmarRegistro(Map<String, dynamic> datos) async {
    _setLoading(true);
    _setStatusMessage(null);

    int? estadoIdActual; // Para trackear solo el registro actual

    try {
      _logger.i('üìù CONFIRMANDO REGISTRO - GUARDADO DEFINITIVO EN BD');

      final cliente = datos['cliente'] as Cliente;
      final equipoCompleto = datos['equipo_completo'] as Map<String, dynamic>?;
      final yaAsignado = datos['ya_asignado'] as bool? ?? false;
      final esCenso = datos['es_censo'] as bool? ?? true;

      // ‚úÖ PASO 1: GUARDAR ASIGNACI√ìN EN BD (usando procesarEscaneoCenso)
      if (esCenso && equipoCompleto != null && !yaAsignado) {
        _setStatusMessage('üíæ Registrando asignaci√≥n del equipo...');

        try {
          await _equipoClienteRepository.procesarEscaneoCenso(
            equipoId: equipoCompleto['id'],
            clienteId: cliente.id!,
          );
          _logger.i('‚úÖ Asignaci√≥n equipo-cliente procesada');
        } catch (e) {
          _logger.w('‚ö†Ô∏è Equipo ya asignado a otro cliente: $e');
        }
      }

      // ‚úÖ PASO 2: REGISTRAR EN HISTORIAL CON ESTADO 'CREADO'
      if (equipoCompleto != null) {
        _setStatusMessage('üìã Registrando estado como CREADO...');

        // Buscar equipoClienteId
        final equipoClienteId = await _estadoEquipoRepository.buscarEquipoClienteId(
          equipoCompleto['id'],
          cliente.id!,
        );

        if (equipoClienteId != null) {
          // Crear estado con estado "creado"
          final estadoCreado = await _estadoEquipoRepository.crearNuevoEstadoCenso(
            equipoClienteId: equipoClienteId,
            latitud: datos['latitud'],
            longitud: datos['longitud'],
            fechaRevision: DateTime.now(),
            enLocal: true,
            observaciones: datos['observaciones']?.toString(),

            // NUEVOS PARAMETROS DE IMAGEN
            imagenPath: datos['imagen_path'],
            imagenBase64: datos['imagen_base64'],
            tieneImagen: datos['tiene_imagen'] ?? false,
            imagenTamano: datos['imagen_tamano'],
          );

          estadoIdActual = estadoCreado.id; // Guardar ID del registro actual
          _logger.i('‚úÖ Estado CREADO registrado con ID: $estadoIdActual');
        } else {
          _logger.w('No se encontr√≥ relaci√≥n equipo_cliente');
          _setStatusMessage('‚ö†Ô∏è Advertencia: No se registr√≥ en historial');
        }
      }

      // ‚úÖ PASO 3: PREPARAR DATOS PARA API USANDO EL ESTADO CREADO
      _setStatusMessage('üì§ Preparando datos para migraci√≥n...');
      Map<String, dynamic> datosCompletos;

      if (estadoIdActual != null) {
        // Obtener el estado reci√©n creado con todos sus datos
        final estadoCreado = await _estadoEquipoRepository.obtenerPorId(estadoIdActual);
        if (estadoCreado != null) {
          datosCompletos = await _prepararDatosDesdeEstado(estadoCreado);
        } else {
          throw 'No se pudo obtener el estado creado con ID: $estadoIdActual';
        }
      } else {
        // Fallback al m√©todo anterior si no hay estado creado
        datosCompletos = _prepararDatosParaEnvio(datos);
      }

      // ‚úÖ PASO 4: GUARDAR REGISTRO LOCAL MAESTRO
      _setStatusMessage('üíæ Guardando registro local maestro...');
      await _guardarRegistroLocal(datosCompletos);

      // ‚úÖ PASO 5: INTENTAR MIGRAR SOLO EL REGISTRO ACTUAL (CON TIMEOUT CORTO)
      _setStatusMessage('üîÑ Sincronizando registro actual...');

      String mensajeFinal;
      bool migracionExitosa = false;

      if (estadoIdActual != null) {
        final respuestaServidor = await _intentarEnviarAlServidorConTimeout(
            datosCompletos,
            timeoutSegundos: 8 // Timeout corto para no bloquear UI
        );

        _logger.i('üîç Respuesta completa del servidor: $respuestaServidor');

        if (respuestaServidor['exito'] == true) {
          _logger.i('‚úÖ Marcando estado como migrado con ID: $estadoIdActual');

          // Migrar solo el registro actual
          await _estadoEquipoRepository.marcarComoMigrado(
            estadoIdActual,
            servidorId: respuestaServidor['servidor_id'],
          );

          await _marcarComoSincronizado(datosCompletos['id_local'] as int);

          mensajeFinal = 'Censo completado y sincronizado al servidor';
          migracionExitosa = true;
          _setStatusMessage('‚úÖ Registro sincronizado exitosamente');

          _logger.i('‚úÖ Estado $estadoIdActual marcado como migrado exitosamente');

        } else {
          _logger.w('‚ö†Ô∏è Migraci√≥n no exitosa: ${respuestaServidor['motivo']} - ${respuestaServidor['detalle']}');

          // El registro queda en estado "creado" para migrar despu√©s
          mensajeFinal = 'Censo guardado localmente. Se sincronizar√° autom√°ticamente';
          _setStatusMessage('üì± Censo guardado. Sincronizaci√≥n autom√°tica pendiente');
        }
      } else {
        mensajeFinal = 'Censo guardado localmente';
      }

      // ‚úÖ PASO 6: PROGRAMAR SINCRONIZACI√ìN EN BACKGROUND PARA REGISTROS PENDIENTES
      _programarSincronizacionBackground();

      return {
        'success': true,
        'message': mensajeFinal,
        'migrado_inmediatamente': migracionExitosa
      };

    } catch (e) {
      _logger.e('‚ùå Error cr√≠tico en confirmaci√≥n de registro: $e');
      return {'success': false, 'error': 'Error guardando registro: $e'};
    } finally {
      _setLoading(false);
    }
  }

  /// Intentar env√≠o al servidor con timeout espec√≠fico
  Future<Map<String, dynamic>> _intentarEnviarAlServidorConTimeout(
      Map<String, dynamic> datos,
      {int timeoutSegundos = 8}
      ) async {
    try {
      // Verificar conectividad con timeout corto
      final tieneConexion = await _verificarConectividadRapida();
      if (!tieneConexion) {
        _logger.w('‚ö†Ô∏è Sin conexi√≥n al servidor');
        return {'exito': false, 'motivo': 'sin_conexion'};
      }

      // Preparar datos para API
      final datosApi = _prepararDatosParaApiEstados(datos);
      _logger.i('üîç Datos preparados para API: ${json.encode(datosApi)}');

      // Enviar con timeout espec√≠fico
      final response = await _enviarAApiEstadosConTimeout(datosApi, timeoutSegundos);

      _logger.i('üîç Respuesta de _enviarAApiEstadosConTimeout: $response');

      if (response['exito'] == true) {
        _logger.i('‚úÖ Estado registrado exitosamente en servidor');
        return {
          'exito': true,
          'servidor_id': response['id'],
          'mensaje': response['mensaje']
        };
      } else {
        _logger.w('‚ö†Ô∏è Respuesta no exitosa del servidor: ${response['mensaje']}');
        return {
          'exito': false,
          'motivo': 'error_servidor',
          'detalle': response['mensaje']
        };
      }

    } catch (e) {
      _logger.e('‚ö†Ô∏è Excepci√≥n en intentarEnviarAlServidorConTimeout: $e');
      return {
        'exito': false,
        'motivo': 'timeout_o_error',
        'detalle': e.toString()
      };
    }
  }

  /// Verificaci√≥n de conectividad r√°pida (timeout de 3 segundos)
  Future<bool> _verificarConectividadRapida() async {
    try {
      _logger.i('üåê Verificaci√≥n r√°pida de conectividad...');

      final response = await http.get(
        Uri.parse('$_baseUrl$_pingEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(const Duration(seconds: 3)); // Timeout corto

      return response.statusCode == 200;

    } catch (e) {
      _logger.w('‚ö†Ô∏è Conectividad r√°pida fall√≥: $e');
      return false;
    }
  }

  /// Enviar a API con timeout espec√≠fico - SIMPLIFICADO PARA CONSIDERAR CUALQUIER 200 COMO √âXITO
  Future<Map<String, dynamic>> _enviarAApiEstadosConTimeout(
      Map<String, dynamic> datos,
      int timeoutSegundos
      ) async {
    try {
      _logger.i('üì§ Enviando con timeout de ${timeoutSegundos}s: $_baseUrl$_estadosEndpoint');
      _logger.i('üîç Datos a enviar: ${json.encode(datos)}');

      final response = await http.post(
        Uri.parse('$_baseUrl$_estadosEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json.encode(datos),
      ).timeout(Duration(seconds: timeoutSegundos));

      _logger.i('üì• Respuesta Status: ${response.statusCode}');
      _logger.i('üìÑ Respuesta Body: ${response.body}');

      // ‚úÖ CUALQUIER STATUS 200-299 SE CONSIDERA √âXITO
      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.i('‚úÖ Status HTTP exitoso: ${response.statusCode} - Marcando como exitoso autom√°ticamente');

        dynamic servidorId = DateTime.now().millisecondsSinceEpoch; // ID por defecto
        String mensaje = 'Estado registrado correctamente';

        // Intentar parsear respuesta pero sin fallar si no es JSON v√°lido
        try {
          final responseBody = json.decode(response.body);
          _logger.i('üìã Response body parseado: $responseBody');

          // Extraer ID si est√° disponible
          servidorId = responseBody['estado']?['id'] ??
              responseBody['id'] ??
              responseBody['insertId'] ??
              servidorId; // Usar el timestamp como fallback

          // Usar mensaje del servidor si est√° disponible
          if (responseBody['message'] != null) {
            mensaje = responseBody['message'].toString();
          }

        } catch (parseError) {
          _logger.w('‚ö†Ô∏è No se pudo parsear JSON, usando valores por defecto: $parseError');
          // Mantener los valores por defecto ya asignados
        }

        return {
          'exito': true,
          'id': servidorId,
          'mensaje': mensaje
        };
      }
      // Status no exitoso (4xx, 5xx)
      else {
        _logger.e('‚ùå Status HTTP no exitoso: ${response.statusCode}');

        String mensajeError = 'Error del servidor: ${response.statusCode}';
        try {
          final errorBody = json.decode(response.body);
          mensajeError = errorBody['message'] ?? mensajeError;
        } catch (e) {
          // Si no se puede parsear, usar mensaje por defecto
          mensajeError = 'Error HTTP ${response.statusCode}';
        }

        return {
          'exito': false,
          'mensaje': mensajeError
        };
      }

    } catch (e) {
      _logger.e('‚ùå Excepci√≥n enviando a API: $e');
      return {
        'exito': false,
        'mensaje': 'Error de conexi√≥n: $e'
      };
    }
  }

  /// Programar sincronizaci√≥n en background para registros pendientes
  void _programarSincronizacionBackground() {
    // Ejecutar despu√©s de un delay inicial para que la UI responda primero
    Timer(Duration(seconds: 5), () async {
      try {
        _logger.i('üîÑ Iniciando primera sincronizaci√≥n background de registros pendientes');
        await _sincronizarRegistrosPendientesEnBackground();
      } catch (e) {
        _logger.e('‚ùå Error en sincronizaci√≥n background: $e');
      }
    });

    // Programar sincronizaci√≥n peri√≥dica cada 10 minutos
    _programarSincronizacionPeriodica();
  }

  void _programarSincronizacionPeriodica() {
    Timer.periodic(Duration(minutes: 30), (timer) async {
      try {
        _logger.i('‚è∞ Sincronizaci√≥n autom√°tica programada (cada 10 min)');

        // Verificar si hay registros pendientes antes de intentar
        final registrosCreados = await _estadoEquipoRepository.obtenerCreados();

        if (registrosCreados.isNotEmpty) {
          _logger.i('üìã Encontrados ${registrosCreados.length} registros pendientes para sincronizar');
          await _sincronizarRegistrosPendientesEnBackground();
        } else {
          _logger.i('‚úÖ No hay registros pendientes para sincronizar');
        }
      } catch (e) {
        _logger.e('‚ùå Error en sincronizaci√≥n peri√≥dica: $e');
      }
    });
  }

  /// Sincronizar registros pendientes sin bloquear la UI
  Future<void> _sincronizarRegistrosPendientesEnBackground() async {
    try {
      // Obtener registros en estado "creado" (excluyendo el que se acaba de procesar)
      final registrosCreados = await _estadoEquipoRepository.obtenerCreados();

      if (registrosCreados.isEmpty) {
        _logger.i('‚úÖ No hay registros pendientes para sincronizar en background');
        return;
      }

      _logger.i('üìã Sincronizando ${registrosCreados.length} registros pendientes en background');

      int migrados = 0;
      int fallos = 0;

      // Procesar de a uno con delays para no saturar el servidor
      for (int i = 0; i < registrosCreados.length; i++) {
        final estado = registrosCreados[i];

        try {
          // Delay entre requests para no saturar
          if (i > 0) {
            await Future.delayed(Duration(milliseconds: 800));
          }

          final exito = await _procesarEstadoIndividualEnBackground(estado);

          if (exito) {
            migrados++;
            _logger.i('‚úÖ Estado ${estado.id} migrado en background');
          } else {
            fallos++;
            _logger.w('‚ùå Fallo migrando estado ${estado.id} en background');
          }

          // Cada 5 registros, hacer una pausa m√°s larga
          if ((i + 1) % 5 == 0) {
            await Future.delayed(Duration(seconds: 2));
          }

        } catch (e) {
          fallos++;
          _logger.e('‚ùå Excepci√≥n procesando estado ${estado.id}: $e');
        }
      }

      _logger.i('üìä Sincronizaci√≥n background completada: $migrados migrados, $fallos fallos');

    } catch (e) {
      _logger.e('‚ùå Error en sincronizaci√≥n background: $e');
    }
  }

  /// Procesar un estado individual en background
  Future<bool> _procesarEstadoIndividualEnBackground(EstadoEquipo estado) async {
    try {
      // Preparar datos desde el estado existente
      final datosParaServidor = await _prepararDatosDesdeEstado(estado);

      // Intentar enviar con timeout m√°s largo en background
      final respuesta = await _intentarEnviarAlServidorConTimeout(
          datosParaServidor,
          timeoutSegundos: 15
      );

      if (respuesta['exito']) {
        // Marcar como migrado
        await _estadoEquipoRepository.marcarComoMigrado(
          estado.id!,
          servidorId: respuesta['servidor_id'],
        );
        return true;
      } else {
        // Mantener en estado "creado" para reintento posterior
        return false;
      }

    } catch (e) {
      _logger.e('‚ùå Error procesando estado individual: $e');
      return false;
    }
  }

  /// Preparar datos desde un estado existente - MEJORADO PARA INCLUIR TODOS LOS CAMPOS
  Future<Map<String, dynamic>> _prepararDatosDesdeEstado(EstadoEquipo estado) async {
    try {
      // Obtener detalles completos del estado
      final estadoConDetalles = await _estadoEquipoRepository.obtenerEstadoConDetalles(estado.equipoClienteId);

      if (estadoConDetalles == null) {
        throw 'No se encontraron detalles para el estado ${estado.id}';
      }

      return {
        // Datos locales para control
        'id_local': estado.id,
        'estado_sincronizacion': 'background',
        'fecha_creacion_local': estado.fechaCreacion.toIso8601String(),

        // Datos para API - INCLUIR TODOS LOS CAMPOS DEL ESTADO
        'equipo_id': estadoConDetalles['equipo_id'],
        'cliente_id': estadoConDetalles['cliente_id'],
        'usuario_id': 1,
        'funcionando': true,
        'temperatura_actual': null,
        'temperatura_freezer': null,
        'latitud': estado.latitud,
        'longitud': estado.longitud,

        // ‚úÖ INCLUIR DATOS DE IMAGEN
        'imagen_path': estado.imagenPath,
        'imagen_base64': estado.imagenBase64,
        'tiene_imagen': estado.tieneImagen,
        'imagen_tamano': estado.imagenTamano,

        // Datos adicionales del equipo
        'codigo_barras': estadoConDetalles['cod_barras'],
        'numero_serie': estadoConDetalles['numero_serie'],
        'modelo': estadoConDetalles['modelo'] ?? 'No especificado',
        'logo': estadoConDetalles['logo'] ?? 'Sin logo',
        'marca_nombre': estadoConDetalles['marca_nombre'],

        // Datos del cliente
        'cliente_nombre': estadoConDetalles['cliente_nombre'],

        // Metadatos
        'es_censo': true,
        'version_app': '1.0.0',
        'dispositivo': Platform.operatingSystem,
        'fecha_revision': estado.fechaRevision.toIso8601String(),
        'en_local': estado.enLocal,
      };

    } catch (e) {
      _logger.e('Error preparando datos desde estado: $e');
      rethrow;
    }
  }

  Map<String, dynamic> _prepararDatosParaEnvio(Map<String, dynamic> datos) {
    final cliente = datos['cliente'] as Cliente;
    final equipoCompleto = datos['equipo_completo'] as Map<String, dynamic>?;

    return {
      // Datos locales para control
      'id_local': DateTime.now().millisecondsSinceEpoch,
      'estado_sincronizacion': 'pendiente',
      'fecha_creacion_local': DateTime.now().toIso8601String(),

      // Datos para API /estados (seg√∫n tu esquema)
      'equipo_id': equipoCompleto?['id'] ?? _buscarEquipoPorCodigo(datos['codigo_barras']),
      'cliente_id': cliente.id,
      'usuario_id': 1, // TODO: Obtener del usuario logueado
      'funcionando': true, // Asumimos que est√° funcionando al registrar
      'estado_general': 'Equipo registrado desde APP m√≥vil - ${datos['observaciones'] ?? 'Sin observaciones'}',
      'temperatura_actual': null, // Se actualizar√° en pr√≥ximas revisiones
      'temperatura_freezer': null, // Se actualizar√° en pr√≥ximas revisiones
      'latitud': datos['latitud'],
      'longitud': datos['longitud'],

      // ‚úÖ INCLUIR DATOS DE IMAGEN EN EL M√âTODO ORIGINAL TAMBI√âN
      'imagen_path': datos['imagen_path'],
      'imagen_base64': datos['imagen_base64'],
      'tiene_imagen': datos['tiene_imagen'] ?? false,
      'imagen_tamano': datos['imagen_tamano'],

      // Datos adicionales para referencia local
      'codigo_barras': datos['codigo_barras'],
      'modelo': datos['modelo'],
      'logo': datos['logo'],
      'numero_serie': datos['numero_serie'],
      'observaciones': datos['observaciones'],
      'fecha_registro': datos['fecha_registro'],
      'timestamp_gps': datos['timestamp_gps'],
      'es_censo': datos['es_censo'],
      'ya_asignado': datos['ya_asignado'],
      'version_app': '1.0.0',
      'dispositivo': Platform.operatingSystem,
    };
  }

  int? _buscarEquipoPorCodigo(String? codigoBarras) {
    // TODO: Implementar b√∫squeda real en base de datos local
    // o hacer una consulta a /equipos/buscar?q=codigo

    if (codigoBarras == null) return null;

    // Simulamos que encontramos el equipo basado en el c√≥digo
    // En una implementaci√≥n real, buscar√≠as en tu base de datos local
    // o har√≠as una petici√≥n a tu API para obtener el equipo_id
    return 1; // Provisional - deber√≠a ser el ID real del equipo
  }

  Future<void> _guardarRegistroLocal(Map<String, dynamic> datos) async {
    try {
      _logger.i('üíæ Guardando registro maestro en base de datos local...');

      // TODO: Implementar guardado en SQLite local
      // final db = await DatabaseHelper.instance.database;
      // await db.insert('registros_equipos', datos);

      // Simulaci√≥n por ahora
      await Future.delayed(const Duration(seconds: 1));

      _logger.i('‚úÖ Registro maestro guardado localmente con ID: ${datos['id_local']}');
    } catch (e) {
      _logger.e('‚ùå Error cr√≠tico guardando localmente: $e');
      throw 'Error guardando datos localmente. Verifica el almacenamiento del dispositivo.';
    }
  }

  Future<Map<String, dynamic>> _intentarEnviarAlServidor(Map<String, dynamic> datos) async {
    try {
      // Verificar conectividad con tu servidor
      final tieneConexion = await _verificarConectividad();
      if (!tieneConexion) {
        _logger.w('‚ö†Ô∏è Sin conexi√≥n al servidor');
        return {'exito': false, 'motivo': 'sin_conexion'};
      }

      // Preparar datos para tu API /estados
      final datosApi = _prepararDatosParaApiEstados(datos);

      // Enviar a tu API
      final response = await _enviarAApiEstados(datosApi);

      if (response['exito']) {
        _logger.i('‚úÖ Estado del equipo registrado en el servidor');
        return {
          'exito': true,
          'servidor_id': response['id'],
          'mensaje': response['mensaje']
        };
      } else {
        _logger.w('‚ö†Ô∏è Error del servidor: ${response['mensaje']}');
        return {
          'exito': false,
          'motivo': 'error_servidor',
          'detalle': response['mensaje']
        };
      }

    } catch (e) {
      _logger.w('‚ö†Ô∏è Error enviando al servidor: $e');
      return {
        'exito': false,
        'motivo': 'excepcion',
        'detalle': e.toString()
      };
    }
  }

  Future<bool> _verificarConectividad() async {
    try {
      _logger.i('üåê Verificando conectividad con tu servidor...');

      final response = await http.get(
        Uri.parse('$_baseUrl$_pingEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        _logger.i('‚úÖ Servidor respondi√≥: ${data['message']}');
        return true;
      }

      return false;

    } catch (e) {
      _logger.w('‚ö†Ô∏è Sin conectividad: $e');
      return false;
    }
  }

  Map<String, dynamic> _prepararDatosParaApiEstados(Map<String, dynamic> datosLocales) {
    return {
      // DATOS B√ÅSICOS
      'equipo_id': datosLocales['equipo_id'],
      'cliente_id': datosLocales['cliente_id'],
      'usuario_id': datosLocales['usuario_id'],
      'funcionando': datosLocales['funcionando'],
      'latitud': datosLocales['latitud'],
      'longitud': datosLocales['longitud'],
      'estado_general': datosLocales['estado_general'],

      // ‚úÖ DATOS DE IMAGEN INCLUIDOS EN LA API
      'imagen_path': datosLocales['imagen_path'],
      'imagen_base64': datosLocales['imagen_base64'],
      'tiene_imagen': datosLocales['tiene_imagen'],
      'imagen_tamano': datosLocales['imagen_tamano'],

      // DATOS COMPLETOS DEL EQUIPO
      'equipo_codigo_barras': datosLocales['codigo_barras'],
      'equipo_numero_serie': datosLocales['numero_serie'],
      'equipo_modelo': datosLocales['modelo'],
      'equipo_logo': datosLocales['logo'],
      'equipo_marca': datosLocales['marca_nombre'],

      // DATOS DEL CLIENTE
      'cliente_nombre': datosLocales['cliente_nombre'],

      // METADATOS
      'es_censo': datosLocales['es_censo'],
      'version_app': datosLocales['version_app'],
      'dispositivo': datosLocales['dispositivo'],
      'fecha_revision': datosLocales['fecha_revision'],
      'en_local': datosLocales['en_local'],
      'observaciones': datosLocales['observaciones'],
    };
  }

  Future<Map<String, dynamic>> _enviarAApiEstados(Map<String, dynamic> datos) async {
    try {
      _logger.i('üì§ Enviando estado a API: $_baseUrl$_estadosEndpoint');
      _logger.i('üìã Datos: $datos');

      final response = await http.post(
        Uri.parse('$_baseUrl$_estadosEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: json.encode(datos),
      ).timeout(const Duration(seconds: 30));

      _logger.i('üì• Respuesta API: ${response.statusCode}');
      _logger.i('üìÑ Body: ${response.body}');

      // ‚úÖ CUALQUIER STATUS 200-299 SE CONSIDERA √âXITO
      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.i('‚úÖ Status HTTP exitoso: ${response.statusCode}');

        dynamic servidorId = DateTime.now().millisecondsSinceEpoch;
        String mensaje = 'Estado registrado correctamente';

        try {
          final responseBody = json.decode(response.body);

          // Intentar extraer el ID del servidor si est√° disponible
          servidorId = responseBody['estado']?['id'] ??
              responseBody['id'] ??
              responseBody['insertId'] ??
              servidorId; // Usar el timestamp como fallback

          // Usar el mensaje del servidor si est√° disponible
          if (responseBody['message'] != null) {
            mensaje = responseBody['message'].toString();
          }

        } catch (parseError) {
          _logger.w('‚ö†Ô∏è Error parseando JSON, pero status es exitoso: $parseError');
          // Mantener valores por defecto
        }

        return {
          'exito': true,
          'id': servidorId,
          'mensaje': mensaje
        };
      } else {
        try {
          final errorBody = json.decode(response.body);
          return {
            'exito': false,
            'mensaje': errorBody['message'] ?? 'Error del servidor: ${response.statusCode}'
          };
        } catch (e) {
          return {
            'exito': false,
            'mensaje': 'Error HTTP ${response.statusCode}: ${response.body}'
          };
        }
      }

    } catch (e) {
      _logger.e('‚ùå Excepci√≥n enviando a API: $e');
      return {
        'exito': false,
        'mensaje': 'Error de conexi√≥n: $e'
      };
    }
  }

  Future<void> _marcarComoSincronizado(int idLocal) async {
    try {
      // TODO: Actualizar estado en SQLite local
      // final db = await DatabaseHelper.instance.database;
      // await db.update(
      //   'registros_equipos',
      //   {'estado_sincronizacion': 'sincronizado'},
      //   where: 'id_local = ?',
      //   whereArgs: [idLocal]
      // );

      _logger.i('‚úÖ Registro marcado como sincronizado: $idLocal');
    } catch (e) {
      _logger.e('‚ùå Error marcando como sincronizado: $e');
    }
  }

  Future<void> _actualizarConIdServidor(int idLocal, dynamic servidorId) async {
    try {
      // TODO: Actualizar con ID del servidor en SQLite
      // final db = await DatabaseHelper.instance.database;
      // await db.update(
      //   'registros_equipos',
      //   {'servidor_id': servidorId},
      //   where: 'id_local = ?',
      //   whereArgs: [idLocal]
      // );

      _logger.i('‚úÖ ID del servidor actualizado: $servidorId para local: $idLocal');
    } catch (e) {
      _logger.e('‚ùå Error actualizando ID servidor: $e');
    }
  }
}